(function(){const pages=[{"idx":0,"href":"/docs/introduction/shortcodes/","title":"Shortcodes","content":"Shortcodes Expand shortcode Default {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Expand â†•  Markdown content Lorem markdownum insigne\u0026hellip;    With Custom Label {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}  Custom Label ...  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    Buttons {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  Tabs {{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}  MacOS  MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Linux  Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Windows  Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n  Columns {{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   Mermaid Chart {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}   sequenceDiagram Alice-\u0026raquo;Bob: Hello Bob, how are you? alt is sick Bob-\u0026raquo;Alice: Not so good :( else is well Bob-\u0026raquo;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026raquo;Alice: Thanks for asking end\n  KaTeX {{\u0026lt; katex \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}     "},{"idx":1,"href":"/docs/esp32/blink/","title":"Blink","content":"ESP32 Getting Started - Blink  .ging{ text-align: center; width: 100%; }    Background The ESP32 line of modules by Espressif contain a dual-core, 32-bit processor capable of click speeds of up to 240 MHz. The module also includes WiFi, Bluetooth, and hardware accelerators for a variety of peripherals. Programming the ESP32 can be done via the Arduino IDE, Espressif\u0026rsquo;s IDF (Integrated Development Framework), or a third-party toolchain. While the Arduino IDE is convenient, using the ESP-IDF enables the user to take full advantage of the dual-core nature of the ESP32, and of standard libraries that interact with peripherals. For these reasons, we will be using the ESP-IDF for this guide. Espressif\u0026rsquo;s ESP-IDF documentation can be found here, and the documentation for FreeRTOS, the barebones, real-time operating system used by ESP-IDF, can be found here. The following guide will show you how to make an RGB LED blink periodically, taking advantage of basic FreeRTOS features and the ESP-IDF. To follow along, you will need an ESP32 development board with an RGB LED attached to pins 23, 5, and 0, however the pin assignments are easy to adjust in the code.\nStep 1: Get ESP-IDF Installation instructions for installing ESP-IDF on Linux, Mac, and Windows can be found here. Once you get to the end of this guide, you should have ESP-IDF all set up, and be able to continue on to step 2.\nStep 2: Create a new project ESP-IDF requires a particular directory structure in order to build projects properly. For this reason, it is often easiest to start a new project by copying an example project and modifying the main .c file. ESP-IDF comes with quite a few examples located in esp-idf/examples. For the sake of this tutorial, a template project can be found here. Download the compressed project directory, unzip, and open the file blink_tutorial/main/blink.c in your favorite editor (I will be using VSCode) to get started.\nStep 3: Include necessary libraries A number of standard libraries must be included in order for this example to work. We will include stdio in order to have the ability to print information over the serial connection, FreeRTOS for system calls, and the gpio library to have access to the GPIO (General Purpose Input/Output) pins on the ESP32 in order to drive the LED. Add the following lines to the top of the blink.c file (blink_tutorial/main/blink.c):\n2 3 4 5  #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;freertos/FreeRTOS.h\u0026#34;#include \u0026#34;freertos/task.h\u0026#34;#include \u0026#34;driver/gpio.h\u0026#34;   In addition to including libraries, we will also create macros for the RGB LED pin assignments. On the dev board I am using, the pins used are GPIO 23, GPIO 0, and GPIO 5. These values can be changed depending on how you have your board wired. For the board I am using, I would add the lines: 7 8 9  #define RED_CHANNEL 23 #define GREEN_CHANNEL 0 #define BLUE_CHANNEL 5  \nBefore we continue, we will also need to add a main function. Like most C and C++ environments, ESP-IDF uses a main function as the entry point into the program. ESP-IDF calls the function \u0026ldquo;app_main\u0026rdquo;. Add the following lines to your blink.c file: 11 12 13 14 15  void app_main() { }  \nStep 4: Setup GPIO pins Before we can start using the GPIO pins, we must first configure the pins for output. The reason for this is that the ESP32 internally can use the same pin for multiple functions, so we must be explicit that these pins are intended to be used for GPIO output. The following lines will configure out previously defined red, green, and blue channels as outputs. Add them at the top of your app_main() function. 14 15 16 17 18 19 20  gpio_pad_select_gpio(RED_CHANNEL); gpio_pad_select_gpio(GREEN_CHANNEL); gpio_pad_select_gpio(BLUE_CHANNEL); gpio_set_direction(RED_CHANNEL, GPIO_MODE_OUTPUT); gpio_set_direction(GREEN_CHANNEL, GPIO_MODE_OUTPUT); gpio_set_direction(BLUE_CHANNEL, GPIO_MODE_OUTPUT);  \nStep 5: Turn the LED on and off Now that the pins are configured, we can toggle them on and off in an infinite loop. Add the following while loop with the gpio_set_level() calls to toggle the pins high and low (1 and 0). 22 23 24 25 26 27 28 29 30  while(1) { gpio_set_level(RED_CHANNEL, 0); gpio_set_level(GREEN_CHANNEL, 0); gpio_set_level(BLUE_CHANNEL, 0); gpio_set_level(RED_CHANNEL, 1); gpio_set_level(GREEN_CHANNEL, 1); gpio_set_level(BLUE_CHANNEL, 1); }  \nStep 6: Add task delays Currently, our program will toggle the LED on and off. The problem is, it will toggle the LED on and off as fast as it can, which is too fast for the human eye to see. In order to slow down the toggling, we will add task delays. These task delays are similar to delays in Arduino with one key difference: they only block the block the current task. This is one of the major benefits to using an RTOS like FreeRTOS, is that we can take advantage of the concept of multiple tasks running in parallel, and delay one without pausing the rest. This advantage is not particularly evident right now (since we only have one task), but is a makes more complex code much simpler. To add one second delays, add the following lines after setting the LED pins high and low: 22 23 24 25 26 27 28 29 30 31 32  while(1) { gpio_set_level(RED_CHANNEL, 0); gpio_set_level(GREEN_CHANNEL, 0); gpio_set_level(BLUE_CHANNEL, 0);  vTaskDelay(1000 / portTICK_PERIOD_MS); gpio_set_level(RED_CHANNEL, 1); gpio_set_level(GREEN_CHANNEL, 1); gpio_set_level(BLUE_CHANNEL, 1);  vTaskDelay(1000 / portTICK_PERIOD_MS); }  \nNotice that the vTaskDelay values are not 1000 milliseconds (1 second), but rather 1000 / portTICK_PERIOD_MS. This is because vTaskDelay() works with the concept of ticks. In order to translate tick into milliseconds, we divide the desired millisecond value by the macro portTICK_PERIOD_MS.\nStep 7: Add serial messages In addition to blinking the LED, we can write messages over the serial terminal when we turn the LED on and when we turn the LED off. To do so, add the following lines before setting the GPIO levels on/off. 22 23 24 25 26 27 28 29 30 31 32 33 34  while(1) { printf(\u0026#34;Turning on the LED\\n\u0026#34;);  gpio_set_level(RED_CHANNEL, 0); gpio_set_level(GREEN_CHANNEL, 0); gpio_set_level(BLUE_CHANNEL, 0); vTaskDelay(1000 / portTICK_PERIOD_MS); printf(\u0026#34;Turning off the LED\\n\u0026#34;);  gpio_set_level(RED_CHANNEL, 1); gpio_set_level(GREEN_CHANNEL, 1); gpio_set_level(BLUE_CHANNEL, 1); vTaskDelay(1000 / portTICK_PERIOD_MS); }  \n note ...  The \u0026ldquo;Turning on the LED\u0026rdquo; and \u0026ldquo;Turning off the LED\u0026rdquo; messages might be backwards on your setup depending on if your RGB LED is common anode or common cathode.    The idf.py tool can be used to read the output of the serial terminal. On Linux, the command is:  .cmd{ background-color: black; color: rgb(53, 216, 31); padding: 0.3em; margin: 0.4em; font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace; }  $ idf.py monitor\nStep 8: Build and upload The basic blink example is now complete and ready to be uploaded. The complete blink.c file should look like this: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;freertos/FreeRTOS.h\u0026#34;#include \u0026#34;freertos/task.h\u0026#34;#include \u0026#34;driver/gpio.h\u0026#34; #define RED_CHANNEL 23 #define GREEN_CHANNEL 0 #define BLUE_CHANNEL 5  void app_main() { gpio_pad_select_gpio(RED_CHANNEL); gpio_pad_select_gpio(GREEN_CHANNEL); gpio_pad_select_gpio(BLUE_CHANNEL); gpio_set_direction(RED_CHANNEL, GPIO_MODE_OUTPUT); gpio_set_direction(GREEN_CHANNEL, GPIO_MODE_OUTPUT); gpio_set_direction(BLUE_CHANNEL, GPIO_MODE_OUTPUT); while(1) { printf(\u0026#34;Turning on the LED\\n\u0026#34;); gpio_set_level(RED_CHANNEL, 0); gpio_set_level(GREEN_CHANNEL, 0); gpio_set_level(BLUE_CHANNEL, 0); vTaskDelay(1000 / portTICK_PERIOD_MS); printf(\u0026#34;Turning off the LED\\n\u0026#34;); gpio_set_level(RED_CHANNEL, 1); gpio_set_level(GREEN_CHANNEL, 1); gpio_set_level(BLUE_CHANNEL, 1); vTaskDelay(1000 / portTICK_PERIOD_MS); } }  \nThe uploading method is the same as in the ESP-IDF install guide found here. On Linux,  .cmd{ background-color: black; color: rgb(53, 216, 31); padding: 0.3em; margin: 0.4em; font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace; }  $ idf.py flash should work.\nThe results should be similar to what is depicted below:\n  .ging{ text-align: center; width: 100%; }     .ging{ text-align: center; width: 100%; }    Step 9: Make it more interesting The above example simply flashes the RGB LED on and off, i.e. all channels are synchronized. A more interesting demo would be to drive each channel individually. A simple method of doing so is shown below: 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  while(1) { printf(\u0026#34;All off\\n\u0026#34;); gpio_set_level(RED_CHANNEL, 1); gpio_set_level(GREEN_CHANNEL, 1); gpio_set_level(BLUE_CHANNEL, 1); vTaskDelay(1000 / portTICK_PERIOD_MS); printf(\u0026#34;Red channel on\\n\u0026#34;); gpio_set_level(RED_CHANNEL, 0); vTaskDelay(1000 / portTICK_PERIOD_MS); printf(\u0026#34;Green channel on\\n\u0026#34;); gpio_set_level(GREEN_CHANNEL, 0); vTaskDelay(1000 / portTICK_PERIOD_MS); printf(\u0026#34;Blue channel on\\n\u0026#34;); gpio_set_level(BLUE_CHANNEL, 0); vTaskDelay(1000 / portTICK_PERIOD_MS); }  \nI would encourage you to experiment with different combinations of the channels and different methods of controlling them.\nStep 10: Hardware LED Driver If you were to actually deploy a final product that used the esp32 to drive LEDs, chances are you will want to use the built-in LED driver. The ESP32\u0026rsquo;s hardware LED driver is capable of changing the intensity of group of LEDs and handle gradual transitions between different intensities while using minimal cpu resources. The exact workings of the LED driver are beyond the scope of this tutorial, but documentation on the LED driver can be found here, and below is a copy of example code provided by Espressif that takes advantage of the LED driver. The LED driver is just one of several hardware-implimented peripheral drivers included in the ESP32. A complete list of the ESP32\u0026rsquo;s peripherals and documentation on them can be found here.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192  /* LEDC (LED Controller) fade example This example code is in the Public Domain (or CC0 licensed, at your option.) Unless required by applicable law or agreed to in writing, this software is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */ #include \u0026lt;stdio.h\u0026gt;#include \u0026#34;freertos/FreeRTOS.h\u0026#34;#include \u0026#34;freertos/task.h\u0026#34;#include \u0026#34;driver/ledc.h\u0026#34;#include \u0026#34;esp_err.h\u0026#34; /* * About this example * * 1. Start with initializing LEDC module: * a. Set the timer of LEDC first, this determines the frequency * and resolution of PWM. * b. Then set the LEDC channel you want to use, * and bind with one of the timers. * * 2. You need first to install a default fade function, * then you can use fade APIs. * * 3. You can also set a target duty directly without fading. * * 4. This example uses GPIO18/19/4/5 as LEDC output, * and it will change the duty repeatedly. * * 5. GPIO18/19 are from high speed channel group. * GPIO4/5 are from low speed channel group. * */ #ifdef CONFIG_IDF_TARGET_ESP32 #define LEDC_HS_TIMER LEDC_TIMER_0 #define LEDC_HS_MODE LEDC_HIGH_SPEED_MODE #define LEDC_HS_CH0_GPIO (18) #define LEDC_HS_CH0_CHANNEL LEDC_CHANNEL_0 #define LEDC_HS_CH1_GPIO (19) #define LEDC_HS_CH1_CHANNEL LEDC_CHANNEL_1 #endif #define LEDC_LS_TIMER LEDC_TIMER_1 #define LEDC_LS_MODE LEDC_LOW_SPEED_MODE #ifdef CONFIG_IDF_TARGET_ESP32S2 #define LEDC_LS_CH0_GPIO (18) #define LEDC_LS_CH0_CHANNEL LEDC_CHANNEL_0 #define LEDC_LS_CH1_GPIO (19) #define LEDC_LS_CH1_CHANNEL LEDC_CHANNEL_1 #endif #define LEDC_LS_CH2_GPIO (4) #define LEDC_LS_CH2_CHANNEL LEDC_CHANNEL_2 #define LEDC_LS_CH3_GPIO (5) #define LEDC_LS_CH3_CHANNEL LEDC_CHANNEL_3  #define LEDC_TEST_CH_NUM (4) #define LEDC_TEST_DUTY (4000) #define LEDC_TEST_FADE_TIME (3000)  void app_main(void) { int ch; /* * Prepare and set configuration of timers * that will be used by LED Controller */ ledc_timer_config_t ledc_timer = { .duty_resolution = LEDC_TIMER_13_BIT, // resolution of PWM duty  .freq_hz = 5000, // frequency of PWM signal  .speed_mode = LEDC_LS_MODE, // timer mode  .timer_num = LEDC_LS_TIMER, // timer index  .clk_cfg = LEDC_AUTO_CLK, // Auto select the source clock  }; // Set configuration of timer0 for high speed channels  ledc_timer_config(\u0026amp;ledc_timer); #ifdef CONFIG_IDF_TARGET_ESP32  // Prepare and set configuration of timer1 for low speed channels  ledc_timer.speed_mode = LEDC_HS_MODE; ledc_timer.timer_num = LEDC_HS_TIMER; ledc_timer_config(\u0026amp;ledc_timer); #endif  /* * Prepare individual configuration * for each channel of LED Controller * by selecting: * - controller\u0026#39;s channel number * - output duty cycle, set initially to 0 * - GPIO number where LED is connected to * - speed mode, either high or low * - timer servicing selected channel * Note: if different channels use one timer, * then frequency and bit_num of these channels * will be the same */ ledc_channel_config_t ledc_channel[LEDC_TEST_CH_NUM] = { #ifdef CONFIG_IDF_TARGET_ESP32  { .channel = LEDC_HS_CH0_CHANNEL, .duty = 0, .gpio_num = LEDC_HS_CH0_GPIO, .speed_mode = LEDC_HS_MODE, .hpoint = 0, .timer_sel = LEDC_HS_TIMER }, { .channel = LEDC_HS_CH1_CHANNEL, .duty = 0, .gpio_num = LEDC_HS_CH1_GPIO, .speed_mode = LEDC_HS_MODE, .hpoint = 0, .timer_sel = LEDC_HS_TIMER }, #elif defined CONFIG_IDF_TARGET_ESP32S2  { .channel = LEDC_LS_CH0_CHANNEL, .duty = 0, .gpio_num = LEDC_LS_CH0_GPIO, .speed_mode = LEDC_LS_MODE, .hpoint = 0, .timer_sel = LEDC_LS_TIMER }, { .channel = LEDC_LS_CH1_CHANNEL, .duty = 0, .gpio_num = LEDC_LS_CH1_GPIO, .speed_mode = LEDC_LS_MODE, .hpoint = 0, .timer_sel = LEDC_LS_TIMER }, #endif  { .channel = LEDC_LS_CH2_CHANNEL, .duty = 0, .gpio_num = LEDC_LS_CH2_GPIO, .speed_mode = LEDC_LS_MODE, .hpoint = 0, .timer_sel = LEDC_LS_TIMER }, { .channel = LEDC_LS_CH3_CHANNEL, .duty = 0, .gpio_num = LEDC_LS_CH3_GPIO, .speed_mode = LEDC_LS_MODE, .hpoint = 0, .timer_sel = LEDC_LS_TIMER }, }; // Set LED Controller with previously prepared configuration  for (ch = 0; ch \u0026lt; LEDC_TEST_CH_NUM; ch++) { ledc_channel_config(\u0026amp;ledc_channel[ch]); } // Initialize fade service.  ledc_fade_func_install(0); while (1) { printf(\u0026#34;1. LEDC fade up to duty = %d\\n\u0026#34;, LEDC_TEST_DUTY); for (ch = 0; ch \u0026lt; LEDC_TEST_CH_NUM; ch++) { ledc_set_fade_with_time(ledc_channel[ch].speed_mode, ledc_channel[ch].channel, LEDC_TEST_DUTY, LEDC_TEST_FADE_TIME); ledc_fade_start(ledc_channel[ch].speed_mode, ledc_channel[ch].channel, LEDC_FADE_NO_WAIT); } vTaskDelay(LEDC_TEST_FADE_TIME / portTICK_PERIOD_MS); printf(\u0026#34;2. LEDC fade down to duty = 0\\n\u0026#34;); for (ch = 0; ch \u0026lt; LEDC_TEST_CH_NUM; ch++) { ledc_set_fade_with_time(ledc_channel[ch].speed_mode, ledc_channel[ch].channel, 0, LEDC_TEST_FADE_TIME); ledc_fade_start(ledc_channel[ch].speed_mode, ledc_channel[ch].channel, LEDC_FADE_NO_WAIT); } vTaskDelay(LEDC_TEST_FADE_TIME / portTICK_PERIOD_MS); printf(\u0026#34;3. LEDC set duty = %d without fade\\n\u0026#34;, LEDC_TEST_DUTY); for (ch = 0; ch \u0026lt; LEDC_TEST_CH_NUM; ch++) { ledc_set_duty(ledc_channel[ch].speed_mode, ledc_channel[ch].channel, LEDC_TEST_DUTY); ledc_update_duty(ledc_channel[ch].speed_mode, ledc_channel[ch].channel); } vTaskDelay(1000 / portTICK_PERIOD_MS); printf(\u0026#34;4. LEDC set duty = 0 without fade\\n\u0026#34;); for (ch = 0; ch \u0026lt; LEDC_TEST_CH_NUM; ch++) { ledc_set_duty(ledc_channel[ch].speed_mode, ledc_channel[ch].channel, 0); ledc_update_duty(ledc_channel[ch].speed_mode, ledc_channel[ch].channel); } vTaskDelay(1000 / portTICK_PERIOD_MS); } }   "},{"idx":2,"href":"/docs/","title":"Docs","content":""},{"idx":3,"href":"/","title":"Home","content":"Home  .ging{ text-align: center; width: 100%; }    This site is a combination of a blog and documentation on projects I am working on. The documentation section is intended as a place for objective guides on things I have done, whereas the blog section if more off-topic and based on my opinion. My intent for this site is three fold: to be a reference for myself, to hopefully help others working on similar projects, and to help me learn topics more efficiently. That being said, I am not an expert on anything. I will try to periodically fix errors as I gain experience, but I cannot guarantee the correctness of anything on this site.\n"},{"idx":4,"href":"/docs/fpga/intro/","title":"Intro","content":"FPGA - (Field Programmable Gate Array) \u0026lt; Insert image here \u0026gt;\nFPGAs, or Field Programmable Gate Arrays, are reconfigurable integrated circuits. They are essentially a sea of gates (In reality, they use \u0026ldquo;logic blocks\u0026rdquo; instead of AND, OR, NOT, etc.) which the user can reconfigure. FPGAs are commonly used to prototype ASICs (Application Specific Integrated Circuits), but offer hobbyists a way to design and use their own custom integrated circuits. FPGAs tend to be slower than ASICs, and are often limited to clock frequencies in the hundreds of megahertz, but can be much faster than programmed general-purpose circuits. This is because you can implement your logic in hardware, instead of running software on static hardware. This allows many tasks to run truly asynchronously and atomically, and in some cases are not limited by the clock frequency.\nThis speedup is most evident when doing stream processing, since you could design a circuit that processes data asynchronously as it comes in and outputs it in real time. For example, if you wanted to take in a signal and perform a FFT (Fast Fourier Transform; a common signal processing tool), you could build a circuit that performs the FFT, instead of writing a program that takes many clock cycles to perform the same task. In addition to being the fastest (except for ASICs) way to implement a digital function, FPGAs also provide a large amount of flexibility. Say, for example, you have a project that needs 3 processing cores, 6 timers, and needs to handle data from dozens of sensors in real time. You could either try to find a mix of ICs that meet your requirements, or you could design a custom processor with an FPGA. Lets say that later you expand your project and actually need 10 timers. If you used an FPGA, this can be accomplished by flashing a new design, instead of needing to order more hardware and re-design your electronics.\nThe reason FPGAs are not used everywhere is primarily due to cost and design effort. Many microprocessor ICs cost a few dollars at most, while a decent FPGA will run you from $50 to $10000 USD. This makes it impractical to place an FPGA in every product. From a maker perspective, though, it isn\u0026rsquo;t too outlandish to buy a single FPGA development board, and use it for a variety of projects (remember, it can be configured as nearly any digital circuit). In particular, the FPGA I am using is the\n"},{"idx":5,"href":"/posts/first/","title":"First","content":"Ha! Beat you all to it!\n"},{"idx":6,"href":"/posts/","title":"Posts","content":""},{"idx":7,"href":"/docs/introduction/one/","title":"one","content":"This it a temporary page for my reference while building this site This is a new section Hello\n What happens when I tab over 4 times? I guess this? git submodule deinit _site git rm _site git submodule add -b gh-pages git@github.com:your-username/your-repo.git public  Looks similar to this, except tabbed over Also, I should be able to use cmd prompt text:\n .cmd{ background-color: black; color: rgb(53, 216, 31); padding: 0.3em; margin: 0.4em; font-family: Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace; }  $ Type this in a terminal {{\u0026lt; cmd \u0026#34;$ Type this in a terminal\u0026#34; \u0026gt;}}  .ging{ text-align: center; width: 100%; }    {{\u0026lt; gimg \u0026#34;https://drive.google.com/file/d/1ByYeWBc8NS7uSZFE7uvNijNIOsZiCgCp/preview\u0026#34; \u0026gt;}}  more ...  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}     Home  {{\u0026lt; button relref=\u0026#34;/\u0026#34; \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}}  MacOS  MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Linux  Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Windows  Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n  {{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   {{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} KaTeX {{\u0026lt; katex \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}     "}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();